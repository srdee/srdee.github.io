---
title: "Final R Reference"
author: "Stella Dee"
date: "2022-11-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# R Reference Guide {.tabset .tabset-pills}


## Loading Data and Packages

The functions library() and require() can both be used to load packages that are already installed. However, require() returns a boolean, which can be handy when sharing code; if the user doesn't already have the package installed, require() can still allow functions to run and allow for clearer error messages. 
```{r readingfiles}
#Use library to load penguin data

library(palmerpenguins)

#Use require for the here package: here() helps access files based off the base RProject directory. To use, list subfolders in quotes:

require(here)

#read.csv() reads in a csv file and stores it as a dataframe. 

ginkgos = read.csv(here("data","ginkgo_data_2022.csv"))

```

## Data Structures

The function c() combines or concatenates its arguments into a vector (a 1-dimensional data structure consisting of 1 or more elements).

All of the elements must be of the same type, e.g. it's not possiblecan’t combine character and numeric types in the same call to c()

Here’s two examples using numeric and character data types:

```{r datastructures}
## Create a vector of numbers:
num_vec  = c(1, 4, 8, 9, 13)

## Create a vector of characters:
char_vec = c("a", "fish", "data is cool","cats","trees")

## Typing the name of the vector into the console prints the contents
num_vec

## The print() function accomplishes the same task:
print(char_vec)

#length() gets the length of any R object for which it's been defined, returning an integer of length 1:

length(char_vec)



```

matrix() creates a matrix in R, or can be used to transform data into a matrix. It can take a number of arguments including but not limited to data, nrow (number of rows), and ncol (number of columns).Here's how to turn the num_vec defined above into a matrix:

```{r matrix}
#Turn the numerical vector above into a 5x1 matrix:

matrix(num_vec, nrow=5, ncol=1)
```

A data frame is a data structure in R that requires column names, unique row names, and where the stored data can be numeric, facts, or characters. It is the most fundamental data structure in R. Columns should contain the same numbers of data. Below is an example to convert num_vec and char_vec into a data frame:
```{r dataframe}
#The data frame below combines the char_vec and num_vec into a data frame. Note that the names of the lists/vectors become the column names by default, and row names are a numerical ordering of the elements: 

data.frame(char_vec, num_vec)

#Let's switch to the ginkgos data frame to explore more data.frame properties

#nrow() gives the number of rows, as an integer:

nrow(ginkgos)

#ncol() gives the number of columns, as an integer:

ncol(ginkgos)

#dim() gives the dimensions of the data.frame (or matrix or vector), returned as rows:
dim(ginkgos)
d <- dim(ginkgos)

#To access just number of rows:
d[1]
```

## Subsetting

There are a variety of ways to subset data in R:

```{r subsetting}
#Subset the ginkgo data to just access the max_depth column, store as variable to not take up whole window:

md <- ginkgos$max_depth

#Show the head of this:
head(md)

#Subset just first row of ginkgo data using []:

ginkgos[1, ]

#Show data in row 2, column 3

ginkgos[2,3]

#Select data in 3rd column of ginkgo data (leaving row space blank allows all rows in the 3rd column):

ginkgos[ ,3]

#Use subset() to retrieve data for only Adelie penguins

adelie <- subset(penguins, species =="Adelie")
head(adelie)

```

## Numerical Data Exploration

There are a number of methods in R that allow the user to quickly retrieve basic statistics concerning the data. 

```{r numexploration}
#Summary shows a range of statistics including counts, means, mins, maxes, and medians for each column of a dataframe:

summary(penguins)

#mean() can be used to calculate the mean of a particular dataframe column. na.rm=TRUE is used to remove empty cells

mean(penguins$bill_depth_mm, na.rm=TRUE)

#sd() is used to compute the standard deviation, or the amount of dispersion of the data. Lower standard deviation means values are clustered closer to the mean. 

sd(penguins$bill_depth_mm, na.rm=TRUE)

```

## Graphical Data Exploration

Base R provides a number of ways to make graphics, including scatterplots, histograms, and boxplots. 


```{r graphexploration}
require(here)
ginkgos = read.csv(here("data","ginkgo_data_2022.csv"))
library(palmerpenguins)

#Create a scatterplot-pch refers to point type and cex scales the axes labels (in this case to 75% of default)

plot(x=ginkgos$max_depth, y=ginkgos$max_width, col="red",pch=9, cex=.75, main="Ginkgo Leaf Depth By Width", xlab="Max Depth (mm)", ylab="Max Width (mm)", xlim=c(19,95), ylim=c(19,130))

#Create a histogram:

#breaks is used to specify the number of bins in which the data is presented

hist(penguins$flipper_length_mm, xlab="Flipper Length (mm)", main="Histogram of Penguin Flipper Lengths", breaks=6)

#Create boxplots using the ginkgo data:

boxplot(ginkgos$petiole_length, main="Ginkgo Petiole Length", ylab="Petiole Length (mm)")

#It is also possible to condition boxplots based on other data:

boxplot(data=ginkgos, max_depth ~ seeds_present, ylab="Max Depth (mm)", xlab="Seeds Present", main="Ginkgo Leaf Depth from Trees \n with and without Seeds Found", cex=.5, ylim=c(20,100))

#You can arrange multiple plots on a single page in R using the par() function to set rows and columns for display:

par(mfrow=c(2,2))
hist(penguins$flipper_length_mm, xlab="Flipper Length (mm)", main="Penguin Flipper Length", breaks=6)
hist(penguins$bill_depth_mm, xlab="Bill Depth (mm)", main="Penguin Bill Depth", breaks=6)
hist(penguins$bill_length_mm, xlab="Bill Length (mm)", main="Penguin Bill Length", breaks=6)
hist(penguins$body_mass_g, xlab="Body Mass (g)", main="Penguin Body Mass", breaks=6)
```

## Distribution Functions

dnorm() and pnorm() operate on normal distributions. Here I'm using them on the penguin data without first checking for normality; with 'real' data, it would be important to first confirm a normal distribution. 

```{r}

#calculate mean and standard deviation for sample data (penguin bill depth)

m = mean(na.omit(penguins$bill_depth_mm))
sd = sd(na.omit(penguins$bill_depth_mm))

#dnorm() calculates the probability density of a single event, where the first argument is the event, the second the mean, and the third the standard deviation

dnorm(14.5, mean=m, sd=sd)

#this means we have a ~8.2% chance of the penguin having a bill depth of 14.5mm, assuming the data is normally distributed (this data may not be)

#pnorm() calculates the probability of observing the event or less of a certain value

pnorm(14.5, mean=m, sd=sd)

#this means we have a ~8.9% chance of observing a bill depth of 14.5mm or less, assuming a normal distribution



```

Binomial distribution functions include pbinom(), dbinom() and qbinom; they work with discrete distributions:

```{r}
#Calculate probability of exactly 4 successes during 25 trials with the probability of success on each trial being .5:

dbinom(4,size = 25,prob = .5)

#Calculate the probability of 4 successes or fewer during 25 trials iwth probability of success on each trial being .5:

pbinom(4, size = 25, prob = .5) 

#Calculate probability of greater than 4 successes with all parameters being equal to those above:

1- pbinom(4, size = 25, prob = .5) 

#Calculate the 50th percentile of a binomial distribution for p=.4:

qbinom(.4, size=25, prob=.5)
```



